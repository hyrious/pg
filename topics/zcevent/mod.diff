diff --git a/InteractiveEvent.js b/InteractiveEvent-mod.js
index b2126c1..c5a5281 100644
--- a/InteractiveEvent.js
+++ b/InteractiveEvent-mod.js
@@ -1,5 +1,11 @@
 //===========================================================================
-// 真实互动事件
+// 真实互动事件 - 定制版 (修改 testDistance 函数)
+//-------––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
+// 需要在 quxios 的 QMovement.js 脚本之后使用
+// 
+// 定制内容
+// 1. 使用 QMovement 的碰撞盒
+// 2. <press> 中添加一个 dir 参数过滤出现时机
 //===========================================================================
 
 /*:zh
@@ -17,11 +23,13 @@
  * 1. 事件备注栏要有 <真实互动事件> (包括 < 尖括号 > 符号)
  * 2. 去掉不满足执行条件的事件
  * 3. 剩下的事件中, 包含以下注释的事件页是「可用操作」
- *    1. <press: key icon_id text style_id>
+ *    1. <press: key icon_id text style_id dir>
  *       key      - 按键
  *       icon_id  - 按键图标
  *       text     - 操作文本, 不能有空格
  *       style_id - 文本样式
+ *       dir      - [2,4,6,8], 不能有空格, 在碰撞后检测主角方向, 此参数可选,
+ *                  2 下, 4 左, 6 右, 8 上
  *    2. <name: text style_id>
  *       text     - 当该页出现在最右侧且有效时, 可用操作列表的标题, 不能有空格
  *       style_id - 标题文本样式
@@ -37,12 +45,36 @@ void (function() {
     };
 
     // 距离角色多近 (格数) 就显示可用操作
-    var Distance = 1;
+    var Distance = 3;
 
     // 高级: 自定义距离判定方式 (覆盖 Distance 配置)
     function testDistance(event, player) {
-        var distance = Math.abs(event.x - player.x) + Math.abs(event.y - player.y);
-        return distance <= Distance;
+        // 飞行时禁用
+        if (player._characterName === "$Actor1_2") {
+            return false;
+        }
+        // 碰撞盒检测
+        var dx = event.x - player.x;
+        var dy = event.y - player.y;
+        // 1. 去掉距离过远的 (单位: 地图单元格), 降低检测压力
+        var distance = Math.abs(dx) + Math.abs(dy);
+        // 这里使用了固定数字 Distance, 也可以根据 event 图像动态决定这个距离
+        if (distance <= Distance) {
+            // 2. 计算角色 -> 事件的方向, 如果角色无法通过 (canPass), 那么返回真
+            var dir;
+            if (Math.abs(dx) > Math.abs(dy)) {
+                dir = dx > 0 ? 4 : 6;
+            } else {
+                dir = dy > 0 ? 8 : 2;
+            }
+            // QMovement 默认的检测距离是 moveTiles() = 1px
+            // 考虑自定义距离的话, 可以把下面一行换为 (其中 4 就是自定义距离)
+            // if (!player.canPixelPass(player._px, player._py, dir, 4)) {
+            if (!player.canPass(player._x, player._y, dir)) {
+                return true;
+            }
+        }
+        return false;
     }
 
     // 参考 Input.keyMapper, <press> 中声明的按键会使用
@@ -65,6 +97,7 @@ void (function() {
         this._interactiveEventPageIndex = -1;
         this._needsRefreshActions = true;
         this._emitRefreshActionsToSprite = false;
+        this._lastPlayerDirection = 0;
     };
 
     Game_Event.prototype.isInteractiveEvent = function() {
@@ -82,6 +115,12 @@ void (function() {
         this._needsRefreshActions = true;
     };
 
+    // "[2]" -> [2]
+    function parseArray(str) {
+        if (!str) return null;
+        return eval(str);
+    }
+
     Game_Event.prototype.refreshInteractiveActions = function() {
         var actions = [];
         var pages = this.event().pages;
@@ -101,15 +140,23 @@ void (function() {
                         action.name = matchName[1];
                         action.nameStyle = parseInt(matchName[2]);
                     }
-                    var matchPress = comment.match(/<press:\s*(\S+)\s+(\d+)\s+(\S+)\s+(\d+)>/);
+                    var matchPress = comment.match(/<press:\s*(\S+)\s+(\d+)\s+(\S+)\s+(\d+)(?:\s+(\S+))?>/);
                     if (matchPress) {
                         action.press = matchPress[1];
                         action.pressIcon = parseInt(matchPress[2]);
                         action.pressText = matchPress[3];
                         action.pressStyle = parseInt(matchPress[4]);
+                        action.pressDir = parseArray(matchPress[5]);
                     }
                 }
             }
+            // 3. 定制内容: 考虑角色方向
+            if (action.pressDir) {
+                if (!action.pressDir.includes($gamePlayer.direction())) {
+                    // 若方向不满足, 跳过此页
+                    continue;
+                }
+            }
             if (action.press) {
                 actions.push(action);
             } else {
@@ -141,6 +188,11 @@ void (function() {
     Game_Event.prototype.update = function() {
         _updateEvent.call(this);
         if (this.isInteractiveEvent()) {
+            var direction = $gamePlayer.direction();
+            if (direction !== this._lastPlayerDirection) {
+                this._lastPlayerDirection = direction;
+                this.requestRefreshActions();
+            }
             this.updateInteractiveEventActions();
             if (this._interactiveEventActions) {
                 for (var i in this._interactiveEventActions) {
